import bpy
from bpy.props import StringProperty, IntProperty
from datetime import datetime, timezone


def textBox(self, sentence, icon='NONE', line=56):
	layout = self.box().column()
	if sentence.startswith('LINK:'):
		url, name = sentence.split('|')
		url = url.split('LINK:', maxsplit=1)[1]
		name = name.split('NAME:', maxsplit=1)[1]
		layout.row().operator('wm.url_open', text=name, icon='URL').url = url
		return None
	sentence = sentence.split(' ')
	mix = sentence.pop(0)
	if sentence == []:
		layout.row().label(text=mix, icon=icon)
		return None
	broken = False
	while True:
		add = ' ' + sentence[0]
		if len(mix + add) < line:
			mix += add
			sentence.pop(0)
			if sentence == []:
				layout.row().label(text=mix, icon='NONE' if broken else icon)
				return None

		else:
			layout.row().label(text=mix, icon='NONE' if broken else icon)
			broken = True
			mix = sentence[0]
			sentence.pop(0)
			if sentence == []:
				layout.row().label(text=mix)
				return None
			
#from textwrap import TextWrapper # may be used in the future
#def label_multiline(
#    context, text, parent, icon=""
#):  # Thanks to B3D Interplanetary for this code snippet
#    chars = int(context.region.width / (7 * context.preferences.view.ui_scale))  # 7 pix on 1 character
#    wrapper = TextWrapper(width=chars)
#    text_lines = wrapper.wrap(text=text)
#    for index, text_line in enumerate(text_lines):
#        if icon and index == 0:
#            parent.label(text=text_line, icon=icon)
#        else:
#            parent.label(text=text_line)

class generictext(bpy.types.Operator):
	text: StringProperty(default='')
	icons: StringProperty()
	size: StringProperty()
	width: IntProperty(default=400)
	url: StringProperty(default='')


def format_time(timestamp):
	# This logic was generated by ChatGPT
	date = datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%SZ')
	date = date.replace(tzinfo=timezone.utc)
	return date.timestamp()


def time_to_calendar(timestamp):
	dt = datetime.fromtimestamp(timestamp)  # local time
	return dt.strftime('%Y-%m-%d %H:%M')


def download_file(url, folder):
	import requests
	import os
	# Replace with the actual URL

	output_filename = url.split('/')[-1]
	output_path = os.path.join(folder, output_filename)

	try:
		response = requests.get(url, stream=True)
		response.raise_for_status()  # Raise an exception for bad status codes

		with open(output_path, 'wb') as f:
			for chunk in response.iter_content(chunk_size=8192):
				f.write(chunk)

	except requests.exceptions.RequestException as e:
		print(f'Error downloading file: {e}')


def play_sound(path, volume=1.0):
	import os

	if not os.path.exists(path):
		return
	import aud

	dev = aud.Device()
	sound = aud.Sound(path)
	dev.volume = volume
	dev.play(sound)


def operator_report(r_type, r_message):
	def sub_report_function():
		bpy.ops.emb.quick_report('INVOKE_DEFAULT', r_type=r_type, r_message=r_message)

	bpy.app.timers.register(sub_report_function)
